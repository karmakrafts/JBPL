package dev.karmakrafts.jbpl.assembler.model.decl;

import dev.karmakrafts.jbpl.assembler.AssemblerContext;
import dev.karmakrafts.jbpl.assembler.model.ScopeOwner;
import dev.karmakrafts.jbpl.assembler.model.element.AbstractElementContainer;
import dev.karmakrafts.jbpl.assembler.model.expr.Expr;
import dev.karmakrafts.jbpl.assembler.model.expr.LiteralExpr;
import dev.karmakrafts.jbpl.assembler.model.statement.ReturnStatement;
import dev.karmakrafts.jbpl.assembler.model.statement.Statement;
import dev.karmakrafts.jbpl.assembler.model.type.BuiltinType;
import dev.karmakrafts.jbpl.assembler.model.type.Type;
import org.jetbrains.annotations.NotNull;

import java.util.LinkedHashMap;
import java.util.Map;

public final class MacroDecl extends AbstractElementContainer implements Declaration, ScopeOwner {
    private final LinkedHashMap<Expr, Expr> parameterTypes = new LinkedHashMap<>();
    private Expr name;
    private Expr returnType;

    public MacroDecl(final @NotNull Expr name, final @NotNull Expr returnType) {
        name.setParent(this);
        this.name = name;
        returnType.setParent(this);
        this.returnType = returnType;
    }

    public void setName(final @NotNull Expr name) {
        if (this.name != null) {
            this.name.setParent(null);
        }
        name.setParent(this);
        this.name = name;
    }

    public @NotNull Expr getName() {
        return name;
    }

    public void setReturnType(final @NotNull Expr returnType) {
        if (this.returnType != null) {
            this.returnType.setParent(null);
        }
        this.returnType = returnType;
    }

    public @NotNull Expr getReturnType() {
        return returnType;
    }

    public void clearParameters() {
        for (final var entry : parameterTypes.entrySet()) {
            entry.getKey().setParent(null);
            entry.getValue().setParent(null);
        }
        parameterTypes.clear();
    }

    public void addParameter(final @NotNull Expr name, final @NotNull Expr type) {
        name.setParent(this);
        type.setParent(this);
        parameterTypes.put(name, type);
    }

    public void addParameters(final @NotNull Map<Expr, Expr> parameters) {
        for (final var entry : parameters.entrySet()) {
            entry.getKey().setParent(this);
            entry.getValue().setParent(this);
        }
        parameterTypes.putAll(parameters);
    }

    public @NotNull Map<Expr, Expr> getParameters() {
        return parameterTypes;
    }

    @Override
    public void evaluate(final @NotNull AssemblerContext context) {
        final var parameters = new LinkedHashMap<String, Type>();
        for (final var entry : parameterTypes.entrySet()) {
            final var name = entry.getKey().evaluateAsConst(context, String.class);
            final var type = entry.getValue().evaluateAsConst(context, Type.class);
            parameters.put(name, type);
        }
        // Pop as many args as we have params from callee frame and eval return type
        final var arguments = context.popValues(parameters.size());
        final var returnType = getReturnType().evaluateAsConst(context, Type.class);

        // Evaluate the macro body in two phases; the element/decl phase and the value phase
        // The Element/Decl phase takes care of any declarations being generated by the macro
        // The value phase takes care of const-evaluating any results returned by the macro
        Expr returnValue = null;
        for(final var element : elements) {
            if(element instanceof ReturnStatement returnStatement) {
                returnValue = returnStatement.getValue();
                break; // When we encounter any return statement, we stop evaluation at this point
            }
            element.evaluate(context); // Invoke the regular in-line evaluation without any direct result
        }

        // Pop the current stack frame
        context.popFrame();
        // Push the call result onto the caller frame when its not void
        if(returnValue == null || returnType == BuiltinType.VOID) {
            return;
        }
        context.pushValue(returnValue); // TODO: ...
    }

    @Override
    public boolean mergeFrameInstructionsOnFrameExit() {
        return true; // Macro calls always their local frame data into the parent frame
    }
}
