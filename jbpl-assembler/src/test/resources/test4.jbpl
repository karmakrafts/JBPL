^define z: i32 = 10
^info "Testing: ${${z} << 1 << 1}"
^define str: string = ${z} as string
^define x: i32 = (${str} as i32) << 1
^info "Cast: ${${str}}"
^info "Parse: ${${x}}"

^define t1: type = typeof(i32)
^define t2: type = typeof(f32)
^define intersect: type = ${t1} + ${t2}
^define intersect2: type = typeof((i32 | i64 | bool | void))
^define t3: type = ${intersect} - typeof(f32)
^info "Type is ${${t3}}"

^info ${t3}

^define d: i32 = default(${t1})
^info ${d}

public static fun <com/example/Example>.testing(): void {
    return
}

^define OFFSET: i32 = 20

^define cond: i32 = 0

^define y: i32 = if (${cond} > 0) 44
    else if (${cond} < 0) 22
    else 88i8

^info "y is ${${y}}"

^define comp: i32 = ${y} <=> ${OFFSET}

^info "HELLO WORLD! ${${comp}}"
^info "HELLO WORLD!"

^macro testing2(s: string, x: i32): i32 {
    ^return -10
}

^macro testing(p: i32): i32 {
    ^define y: i32 = testing2^(s: "Testing", x: 200)
    ^return ${y} * ${p}
}

^define xxx: i32 = 10
^info "Call to testing returned ${testing^(${y})}"

^info "xxx is i32: ${${xxx} is i32}"

^define arr: [i32] = []{0, 1, 2, 4, 8, 16}
^define arr_idx: i32 = 2
^info "Value 2 from arr is ${${arr}[${arr_idx}]}"

^define md_arr: [[i32]] = []{[]{0}, []{1}}
^define sub_arr: [i32] = ${md_arr}[0]
^info "Value from sub-array is ${${sub_arr}[0]}"

public static field <com/example/Example>.test: i32 = ${md_arr}[0][0]

^macro print_pos(x: i32, y: i32, z: i32) {
    ^info "Position at [${${x}}, ${${y}}, ${${z}}]"
}

print_pos^(z: 2, x: 4, y: 6)